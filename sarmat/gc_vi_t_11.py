# -*- coding: utf-8 -*-
"""GC_VI_T_11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ReDZ0luxLlPURcWqM5rbHYviCDcRYSCD
"""

"""
requirements -r
"""

import matplotlib.pyplot as plt
import numpy as np
from keras import layers
from keras import ops
import keras
import tensorflow as tf

"""GC_VI_T_11
target model

![image.png](data:image/png;base64,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)
"""

class DropPath(keras.layers.Layer):
    def __init__(self, rate=0.5, seed=None, **kwargs):
        super().__init__(**kwargs)
        self.rate = rate
        self.seed = seed
        self.rng = np.random.default_rng(seed)
        self.drop_mask = None
        self.last_batch_size = None
    def build(self, input_shape):
        self.drop_mask = ops.zeros((1,), dtype="float32")
        super().build(input_shape)
    def call(self, x, training=None):
        if self.rate == 0.0 or not training:
            return x
        batch_size = x.shape[0] if x.shape[0] is not None else ops.shape(x)[0]

        if batch_size != self.last_batch_size:
            drop_shape = [batch_size] + [1] * (len(x.shape) - 1)
            rand_mask = self.rng.uniform(size=drop_shape)
            self.drop_mask = ops.cast(ops.array(rand_mask > self.rate), x.dtype)
            self.last_batch_size = batch_size
        x = x / (1.0 - self.rate)
        return x * self.drop_mask

    def get_config(self):
        config = super().get_config()
        config.update({"rate": self.rate, "seed": self.seed})
        return config

class SqueezeAndExcitation(layers.Layer):

    def __init__(self, output_dim=None, expansion=0.25, **kwargs):
        super().__init__(**kwargs)
        self.expansion = expansion
        self.output_dim = output_dim

    def build(self, input_shape):
        inp = input_shape[-1]
        self.output_dim = self.output_dim or inp
        self.avg_pool = layers.GlobalAvgPool2D(keepdims=True, name="avg_pool")
        self.fc = [
            layers.Dense(int(inp * self.expansion), use_bias=False, name="fc_0"),
            layers.Activation("gelu", name="fc_1"),
            layers.Dense(self.output_dim, use_bias=False, name="fc_2"),
            layers.Activation("sigmoid", name="fc_3"),
        ]
        super().build(input_shape)

    def call(self, inputs, **kwargs):
        x = self.avg_pool(inputs)
        for layer in self.fc:
            x = layer(x)
        return x * inputs

class ReduceSize(layers.Layer):
    def __init__(self, keepdims=False, **kwargs):
        super().__init__(**kwargs)
        self.keepdims = keepdims
    def build(self, input_shape):
        embed_dim = input_shape[-1]
        dim_out = embed_dim if self.keepdims else 2 * embed_dim
        self.pad1 = layers.ZeroPadding2D(1, name="pad1")
        self.pad2 = layers.ZeroPadding2D(1, name="pad2")
        self.conv = [
            layers.DepthwiseConv2D(
                kernel_size=3, strides=1, padding="valid", use_bias=False, name="conv_0"
            ),
            layers.Activation("gelu", name="conv_1"),
            SqueezeAndExcitation(name="conv_2"),
            layers.Conv2D(
                embed_dim,
                kernel_size=1,
                strides=1,
                padding="valid",
                use_bias=False,
                name="conv_3",
            ),
        ]
        self.reduction = layers.Conv2D(
            dim_out,
            kernel_size=3,
            strides=2,
            padding="valid",
            use_bias=False,
            name="reduction",
        )
        self.norm1 = layers.LayerNormalization(
            -1, 1e-05, name="norm1"
        )
        self.norm2 = layers.LayerNormalization(-1, 1e-05, name="norm2")

    def call(self, inputs, **kwargs):
        x = self.norm1(inputs)
        xr = self.pad1(x)
        for layer in self.conv:
            xr = layer(xr)
        x = x + xr
        x = self.pad2(x)
        x = self.reduction(x)
        x = self.norm2(x)
        return x

class MLP(layers.Layer):
    def __init__(
        self,
        hidden_features=None,
        out_features=None,
        activation="gelu",
        dropout=0.0,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.hidden_features = hidden_features
        self.out_features = out_features
        self.activation = activation
        self.dropout = dropout
    def build(self, input_shape):
        self.in_features = input_shape[-1]
        self.hidden_features = self.hidden_features or self.in_features
        self.out_features = self.out_features or self.in_features
        self.fc1 = layers.Dense(self.hidden_features, name="fc1")
        self.act = layers.Activation(self.activation, name="act")
        self.fc2 = layers.Dense(self.out_features, name="fc2")
        self.drop1 = layers.Dropout(self.dropout, name="drop1")
        self.drop2 = layers.Dropout(self.dropout, name="drop2")
    def call(self, inputs, **kwargs):
        x = self.fc1(inputs)
        x = self.act(x)
        x = self.drop1(x)
        x = self.fc2(x)
        x = self.drop2(x)
        return x

class PatchEmbed(layers.Layer):
    def __init__(self, embed_dim, **kwargs):
        super().__init__(**kwargs)
        self.embed_dim = embed_dim
    def build(self, input_shape):
        self.pad = layers.ZeroPadding2D(1, name="pad")
        self.proj = layers.Conv2D(self.embed_dim, 3, 2, name="proj")
        self.conv_down = ReduceSize(keepdims=True, name="conv_down")
    def call(self, inputs, **kwargs):
        x = self.pad(inputs)
        x = self.proj(x)
        x = self.conv_down(x)
        return x

class FeatureExtraction(layers.Layer):
    def __init__(self, keepdims=False, **kwargs):
        super().__init__(**kwargs)
        self.keepdims = keepdims
    def build(self, input_shape):
        embed_dim = input_shape[-1]
        self.pad1 = layers.ZeroPadding2D(1, name="pad1")
        self.pad2 = layers.ZeroPadding2D(1, name="pad2")
        self.conv = [
            layers.DepthwiseConv2D(3, 1, use_bias=False, name="conv_0"),
            layers.Activation("gelu", name="conv_1"),
            SqueezeAndExcitation(name="conv_2"),
            layers.Conv2D(embed_dim, 1, 1, use_bias=False, name="conv_3"),
        ]
        if not self.keepdims:
            self.pool = layers.MaxPool2D(3, 2, name="pool")
        super().build(input_shape)

    def call(self, inputs, **kwargs):
        x = inputs
        xr = self.pad1(x)
        for layer in self.conv:
            xr = layer(xr)
        x = x + xr
        if not self.keepdims:
            x = self.pool(self.pad2(x))
        return x

class GlobalQueryGenerator(layers.Layer):
    def __init__(self, keepdims=False, **kwargs):
        super().__init__(**kwargs)
        self.keepdims = keepdims
    def build(self, input_shape):
        self.to_q_global = [
            FeatureExtraction(keepdims, name=f"to_q_global_{i}")
            for i, keepdims in enumerate(self.keepdims)
        ]
        super().build(input_shape)

    def call(self, inputs, **kwargs):
        x = inputs
        for layer in self.to_q_global:
            x = layer(x)
        return x

class WindowAttention(layers.Layer):
    def __init__(
        self,
        window_size,
        num_heads,
        global_query,
        qkv_bias=True,
        qk_scale=None,
        attention_dropout=0.0,
        projection_dropout=0.0,
        **kwargs,
    ):
        super().__init__(**kwargs)
        window_size = (window_size, window_size)
        self.window_size = window_size
        self.num_heads = num_heads
        self.global_query = global_query
        self.qkv_bias = qkv_bias
        self.qk_scale = qk_scale
        self.attention_dropout = attention_dropout
        self.projection_dropout = projection_dropout

    def build(self, input_shape):
        embed_dim = input_shape[0][-1]
        head_dim = embed_dim // self.num_heads
        self.scale = self.qk_scale or head_dim**-0.5
        self.qkv_size = 3 - int(self.global_query)
        self.qkv = layers.Dense(
            embed_dim * self.qkv_size, use_bias=self.qkv_bias, name="qkv"
        )
        self.relative_position_bias_table = self.add_weight(
            name="relative_position_bias_table",
            shape=[
                (2 * self.window_size[0] - 1) * (2 * self.window_size[1] - 1),
                self.num_heads,
            ],
            initializer=keras.initializers.TruncatedNormal(stddev=0.02),
            trainable=True,
            dtype=self.dtype,
        )
        self.attn_drop = layers.Dropout(self.attention_dropout, name="attn_drop")
        self.proj = layers.Dense(embed_dim, name="proj")
        self.proj_drop = layers.Dropout(self.projection_dropout, name="proj_drop")
        self.softmax = layers.Activation("softmax", name="softmax")
        super().build(input_shape)

    def get_relative_position_index(self):
        coords_h = ops.arange(self.window_size[0])
        coords_w = ops.arange(self.window_size[1])
        coords = ops.stack(ops.meshgrid(coords_h, coords_w, indexing="ij"), axis=0)
        coords_flatten = ops.reshape(coords, [2, -1])
        relative_coords = coords_flatten[:, :, None] - coords_flatten[:, None, :]
        relative_coords = ops.transpose(relative_coords, axes=[1, 2, 0])
        relative_coords_xx = relative_coords[:, :, 0] + self.window_size[0] - 1
        relative_coords_yy = relative_coords[:, :, 1] + self.window_size[1] - 1
        relative_coords_xx = relative_coords_xx * (2 * self.window_size[1] - 1)
        relative_position_index = relative_coords_xx + relative_coords_yy
        return relative_position_index

    def call(self, inputs, **kwargs):
        if self.global_query:
            inputs, q_global = inputs
            B = ops.shape(q_global)[0]
        else:
            inputs = inputs[0]
        B_, N, C = ops.shape(inputs)
        qkv = self.qkv(inputs)
        qkv = ops.reshape(
            qkv, [B_, N, self.qkv_size, self.num_heads, C // self.num_heads]
        )
        qkv = ops.transpose(qkv, [2, 0, 3, 1, 4])
        if self.global_query:
            k, v = ops.split(
                qkv, indices_or_sections=2, axis=0
            )
            q_global = ops.repeat(
                q_global, repeats=B_ // B, axis=0
            )
            q = ops.reshape(q_global, [B_, N, self.num_heads, C // self.num_heads])
            q = ops.transpose(q, axes=[0, 2, 1, 3])
        else:
            q, k, v = ops.split(qkv, indices_or_sections=3, axis=0)
            q = ops.squeeze(q, axis=0)

        k = ops.squeeze(k, axis=0)
        v = ops.squeeze(v, axis=0)

        q = q * self.scale
        attn = q @ ops.transpose(k, axes=[0, 1, 3, 2])
        relative_position_bias = ops.take(
            self.relative_position_bias_table,
            ops.reshape(self.get_relative_position_index(), [-1]),
        )
        relative_position_bias = ops.reshape(
            relative_position_bias,
            [
                self.window_size[0] * self.window_size[1],
                self.window_size[0] * self.window_size[1],
                -1,
            ],
        )
        relative_position_bias = ops.transpose(relative_position_bias, axes=[2, 0, 1])
        attn = attn + relative_position_bias[None,]
        attn = self.softmax(attn)
        attn = self.attn_drop(attn)

        x = ops.transpose((attn @ v), axes=[0, 2, 1, 3])
        x = ops.reshape(x, [B_, N, C])
        x = self.proj_drop(self.proj(x))
        return x

class Block(layers.Layer):
    def __init__(
        self,
        window_size,
        num_heads,
        global_query,
        mlp_ratio=4.0,
        qkv_bias=True,
        qk_scale=None,
        dropout=0.0,
        attention_dropout=0.0,
        path_drop=0.0,
        activation="gelu",
        layer_scale=None,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.window_size = window_size
        self.num_heads = num_heads
        self.global_query = global_query
        self.mlp_ratio = mlp_ratio
        self.qkv_bias = qkv_bias
        self.qk_scale = qk_scale
        self.dropout = dropout
        self.attention_dropout = attention_dropout
        self.path_drop = path_drop
        self.activation = activation
        self.layer_scale = layer_scale

    def build(self, input_shape):
        B, H, W, C = input_shape[0]
        self.norm1 = layers.LayerNormalization(-1, 1e-05, name="norm1")
        self.attn = WindowAttention(
            window_size=self.window_size,
            num_heads=self.num_heads,
            global_query=self.global_query,
            qkv_bias=self.qkv_bias,
            qk_scale=self.qk_scale,
            attention_dropout=self.attention_dropout,
            projection_dropout=self.dropout,
            name="attn",
        )
        self.drop_path1 = DropPath(self.path_drop)
        self.drop_path2 = DropPath(self.path_drop)
        self.norm2 = layers.LayerNormalization(-1, 1e-05, name="norm2")
        self.mlp = MLP(
            hidden_features=int(C * self.mlp_ratio),
            dropout=self.dropout,
            activation=self.activation,
            name="mlp",
        )
        if self.layer_scale is not None:
            self.gamma1 = self.add_weight(
                name="gamma1",
                shape=[C],
                initializer=keras.initializers.Constant(self.layer_scale),
                trainable=True,
                dtype=self.dtype,
            )
            self.gamma2 = self.add_weight(
                name="gamma2",
                shape=[C],
                initializer=keras.initializers.Constant(self.layer_scale),
                trainable=True,
                dtype=self.dtype,
            )
        else:
            self.gamma1 = 1.0
            self.gamma2 = 1.0
        self.num_windows = int(H // self.window_size) * int(W // self.window_size)
        super().build(input_shape)

    def call(self, inputs, **kwargs):
        if self.global_query:
            inputs, q_global = inputs
        else:
            inputs = inputs[0]
        B, H, W, C = ops.shape(inputs)
        x = self.norm1(inputs)

        x = self.window_partition(x, self.window_size)

        x = ops.reshape(x, [-1, self.window_size * self.window_size, C])

        if self.global_query:
            x = self.attn([x, q_global])
        else:
            x = self.attn([x])

        x = self.window_reverse(x, self.window_size, H, W, C)

        x = inputs + self.drop_path1(x * self.gamma1)
        x = x + self.drop_path2(self.gamma2 * self.mlp(self.norm2(x)))
        return x

    def window_partition(self, x, window_size):

        B, H, W, C = ops.shape(x)
        x = ops.reshape(
            x,
            [
                -1,
                H // window_size,
                window_size,
                W // window_size,
                window_size,
                C,
            ],
        )
        x = ops.transpose(x, axes=[0, 1, 3, 2, 4, 5])
        windows = ops.reshape(x, [-1, window_size, window_size, C])
        return windows

    def window_reverse(self, windows, window_size, H, W, C):

        x = ops.reshape(
            windows,
            [
                -1,
                H // window_size,
                W // window_size,
                window_size,
                window_size,
                C,
            ],
        )
        x = ops.transpose(x, axes=[0, 1, 3, 2, 4, 5])
        x = ops.reshape(x, [-1, H, W, C])
        return x

class Level(layers.Layer):
    def __init__(
        self,
        depth,
        num_heads,
        window_size,
        keepdims,
        downsample=True,
        mlp_ratio=4.0,
        qkv_bias=True,
        qk_scale=None,
        dropout=0.0,
        attention_dropout=0.0,
        path_drop=0.0,
        layer_scale=None,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.depth = depth
        self.num_heads = num_heads
        self.window_size = window_size
        self.keepdims = keepdims
        self.downsample = downsample
        self.mlp_ratio = mlp_ratio
        self.qkv_bias = qkv_bias
        self.qk_scale = qk_scale
        self.dropout = dropout
        self.attention_dropout = attention_dropout
        self.path_drop = path_drop
        self.layer_scale = layer_scale

    def build(self, input_shape):
        path_drop = (
            [self.path_drop] * self.depth
            if not isinstance(self.path_drop, list)
            else self.path_drop
        )
        self.blocks = [
            Block(
                window_size=self.window_size,
                num_heads=self.num_heads,
                global_query=bool(i % 2),
                mlp_ratio=self.mlp_ratio,
                qkv_bias=self.qkv_bias,
                qk_scale=self.qk_scale,
                dropout=self.dropout,
                attention_dropout=self.attention_dropout,
                path_drop=path_drop[i],
                layer_scale=self.layer_scale,
                name=f"blocks_{i}",
            )
            for i in range(self.depth)
        ]
        self.down = ReduceSize(keepdims=False, name="downsample")
        self.q_global_gen = GlobalQueryGenerator(self.keepdims, name="q_global_gen")
        super().build(input_shape)

    def call(self, inputs, **kwargs):
        x = inputs
        q_global = self.q_global_gen(x)
        for i, blk in enumerate(self.blocks):
            if i % 2:
                x = blk([x, q_global])
            else:
                x = blk([x])
        if self.downsample:
            x = self.down(x)
        return x

class GCViT(keras.Model):
    def __init__(
        self,
        window_size,
        embed_dim,
        depths,
        num_heads,
        drop_rate=0.0,
        mlp_ratio=3.0,
        qkv_bias=True,
        qk_scale=None,
        attention_dropout=0.0,
        path_drop=0.1,
        layer_scale=None,
        num_classes=1000,
        head_activation="softmax",
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.window_size = window_size
        self.embed_dim = embed_dim
        self.depths = depths
        self.num_heads = num_heads
        self.drop_rate = drop_rate
        self.mlp_ratio = mlp_ratio
        self.qkv_bias = qkv_bias
        self.qk_scale = qk_scale
        self.attention_dropout = attention_dropout
        self.path_drop = path_drop
        self.layer_scale = layer_scale
        self.num_classes = num_classes
        self.head_activation = head_activation

        self.patch_embed = PatchEmbed(embed_dim=embed_dim, name="patch_embed")
        self.pos_drop = layers.Dropout(drop_rate, name="pos_drop")
        path_drops = np.linspace(0.0, path_drop, sum(depths))
        keepdims = [(0, 0, 0), (0, 0), (1,), (1,)]
        self.levels = []
        for i in range(len(depths)):
            path_drop = path_drops[sum(depths[:i]) : sum(depths[: i + 1])].tolist()
            level = Level(
                depth=depths[i],
                num_heads=num_heads[i],
                window_size=window_size[i],
                keepdims=keepdims[i],
                downsample=(i < len(depths) - 1),
                mlp_ratio=mlp_ratio,
                qkv_bias=qkv_bias,
                qk_scale=qk_scale,
                dropout=drop_rate,
                attention_dropout=attention_dropout,
                path_drop=path_drop,
                layer_scale=layer_scale,
                name=f"levels_{i}",
            )
            self.levels.append(level)
        self.norm = layers.LayerNormalization(axis=-1, epsilon=1e-05, name="norm")
        self.pool = layers.GlobalAvgPool2D(name="pool")
        self.head = layers.Dense(num_classes, name="head", activation=head_activation)

    def build(self, input_shape):
        super().build(input_shape)
        self.built = True

    def call(self, inputs, **kwargs):
        x = self.patch_embed(inputs)
        x = self.pos_drop(x)
        for level in self.levels:
            x = level(x)
        x = self.norm(x)
        x = self.pool(x)
        x = self.head(x)
        return x

    def build_graph(self, input_shape=(224, 224, 3)):

        x = keras.Input(shape=input_shape)
        return keras.Model(inputs=[x], outputs=self.call(x), name=self.name)

    def summary(self, input_shape=(224, 224, 3)):
        return self.build_graph(input_shape).summary()

from google.colab import files
uploaded = files.upload()

ckpt_path = r"/content/gcvitxxtiny.keras"
config = {
    "window_size": (7, 7, 14, 7),
    "embed_dim": 64,
    "depths": (2, 2, 6, 2),
    "num_heads": (2, 4, 8, 16),
    "mlp_ratio": 3.0,
    "path_drop": 0.2,
}

model = GCViT(**config)
inp = ops.array(np.random.uniform(size=(1, 224, 224, 3)))
out = model(inp)

ckpt_path = r"/content/gcvitxxtiny.keras"
model.load_weights(ckpt_path)


model.summary((224, 224, 3))

IMAGE_SIZE = (224, 224)
BATCH_SIZE = 32
EPOCHS = 5
CLASSES = ['Moon_jellyfish', 'barrel_jellyfish', 'blue_jellyfish', 'compass_jellyfish', 'lions_mane_jellyfish', 'mauve_stinger_jellyfish']
MEAN = 255 * np.array([0.485, 0.456, 0.406], dtype="float32")
STD = 255 * np.array([0.229, 0.224, 0.225], dtype="float32")
AUTO = tf.data.AUTOTUNE

data_dir = r"/content/drive/MyDrive/concave"

full_dataset = keras.utils.image_dataset_from_directory(
    data_dir,
    labels="inferred",
    label_mode="int",
    class_names=CLASSES,
    color_mode="rgb",
    batch_size=None,
    image_size=IMAGE_SIZE,
    shuffle=True,
    seed=42,
)
dataset_size = full_dataset.cardinality().numpy()
train_size = int(0.9 * dataset_size)
val_size = dataset_size - train_size

train_dataset = full_dataset.take(train_size)
val_dataset = full_dataset.skip(train_size)

def make_dataset(dataset: tf.data.Dataset, train: bool, image_size: int = IMAGE_SIZE):
    def preprocess(image, label):
        if train:
            if tf.random.uniform(shape=[]) > 0.5:
                image = tf.image.flip_left_right(image)
        image = tf.image.resize(image, size=image_size, method="bicubic")
        image = (image - MEAN) / STD
        return image, label

    if train:
        dataset = dataset.shuffle(BATCH_SIZE * 10)

    return dataset.map(preprocess, AUTO).batch(BATCH_SIZE).prefetch(AUTO)

train_dataset = make_dataset(train_dataset, train=True)
val_dataset = make_dataset(val_dataset, train=False)

model = GCViT(**config, num_classes=6)
inp = ops.array(np.random.uniform(size=(1, 224, 224, 3)))
out = model(inp)

model.load_weights(ckpt_path, skip_mismatch=True)

model.compile(
    loss="sparse_categorical_crossentropy", optimizer="adam", metrics=["accuracy"]
)

history = model.fit(
    train_dataset, validation_data=val_dataset, epochs=EPOCHS, verbose=1
)

print("Accuracy of the model:", history.history["accuracy"][-1])
print("Validation Accuracy of the model:", history.history["val_accuracy"][-1])

from sklearn.metrics import classification_report
y_true = []
y_pred = []

for images, labels in val_dataset:
    preds = model.predict(images)
    y_true.extend(labels.numpy())
    y_pred.extend(np.argmax(preds, axis=1))
print(classification_report(y_true, y_pred, target_names=CLASSES))